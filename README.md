## 0 项目相关

#### 0.1 redis的持久化，你在项目中用了哪个，为什么？



#### 0.2 mysql你项目中做过哪些优化?







## 1.滴滴秋储一面

#### 1.1 用户态和内核态的区别？

>用户态不能访问硬件和关键资源，只能访问用户空间内存，内核态可以直接访问全部的资源和内存；
>用户态通过调用申请内核服务，内核态直接使用；
>用户态的程序崩溃不影响系统，内核态崩溃可能导致系统崩溃；
>二者通过中断、异常和系统调用切换；

#### 1.2用户态怎么切换到内核态？

> 系统调用，如软中断和专用指令；
> 硬件中断，由外部设备触发，如鼠标；
> 异常，cpu执行指令时发生错误，如除零

#### 1.3进程之间如何通信？

> 管道：单向通信，基于字节流。匿名管道只能用于有亲缘关系的进程，命名管道可跨无关进程。
> 消息队列：内核维护的链表结构，可异步通信，无需同步，可独立读写，但消息大小受限。
> 共享内存：速度快，但是需要配合信号量和锁。
> 信号：内核向进程发起通知，但不能传数据。
> 信号量：计数器，用于进程间同步。
> 套接字：支持跨网通信和本地进程。
> 文件锁：对文件加锁进行多线程访问。

#### 1.4讲一下jvm的内存模型?

> 主要分为**线程私有**和**共有**两个部分
>
> * 私有：
>   * 程序计数器：记录线程执行的位置；
>   * Java虚拟机栈：存储方法调用和执行；
>   * 本地方法栈：为Native方法服务；
> * 共有：
>   * 堆：线程共享数据区，存放对象实例和数组；
>   * 方法区：存储呗虚拟机加载的类、常量、静态变量等；
>     * 运行时常量池：方法区的一部分；

#### 1.5 synchronized了解吗？

> 基本的线程同步机制，提供互斥、可见和可重入性。用于方法和代码块；
> 与volatile的区别：
> 	* s保证代码块的原子性；v只保证单次读写的原子性；
> 	* s保证有序性；v一定程度上保证（禁止指令重排）；
> 	* s会阻塞线程；v不会；
> 	* s用于代码块；v用于变量；

#### 1.6 偏向锁和轻量锁的区别？

> **偏向锁**针对只有一个线程访问同步块的场景优化；**轻量锁**针对有多个线程交替访问同步块的场景；
> **偏向锁**加锁无额外开销，解锁有较大开销；**轻量锁**无竞争时性能接近偏向锁，有竞争时会进行自旋（忙等待），消耗cpu，适用于低并发；
> 当第一个线程上**偏向锁**时，再来第二个线程，会升级为**轻量锁**；当**轻量锁**自旋失败，会升级为**重量级锁**；

#### 1.7 Arraylist和linkdlist的区别是什么

> a基于动态数组实现，支持通过索引快速随机访问；l基于双向链表实现；
> a默认初始容量为10，扩容时增加50%；
> 基于链表和数组的特性导致的时间开销（随机访问、头插、尾插、中间插入、内存占用）；

#### 1.8 arraylist线程安全吗？如果不安全应该用什么？

> 不安全，不是原子性的，可以使用：
> Collections.synchronizedList：原理：所有的方法加synchronized锁；
> 高并发性能较差，串行访问；
> CopywriteArrayList：原理：读写分离，适合读多写少场景；
> 读操作无锁性能高、写操作线程安全；写操作开销大，不适合频繁修改场景。
> Vector：原理：所有方法加synchronized锁；
> 已过时，不推荐。

#### 1.9 对不可变类写时复制的理解？

> **不可变类**：实例创建后状态不能修改的类（String、Interger），每次修改都会返回一个新对象。
> 特点：所有字段用final修饰、不提供setter方法、类本身声明为final。
> 优势：线程安全
> **写时复制**：一种延迟复制的优化策略，适用于读多写少场景，读操作无需加锁（如CopyOnWriteArraylist、CopyOnWriteArraySet），写操作加锁。

#### 1.10 CopyOnArrayList有什么缺点？

> 采用写时复制：写操作性能差，每次修改都会复制底层数据，内存和cpu占用高，使用场景受限（读多写少）；
> 弱一致性：读操作访问旧数据，可能访问到未修改的数据；迭代器基于创建时的数组快照，无法感知后续修改；
> 不支持实时检测：调用迭代器后，其他线程修改列表，不会报错，也看不见新数据；
> 批量写效率低；

#### 1.11 Mysql的索引分类？

> 按照数据结构：B+Tree索引、Hash索引、全文索引、R—Tree索引（空间索引）；
> 按照物理存储分类：聚簇索引、非聚簇索引；
> 按照应用维度：主键、普通、唯一、全文、前缀、降序、函数索引

#### 1.12 InnoDB和MyISAM执行语句哪个快？

> select:InnoDB需要处理事务稍慢；
> insert、update、delete：innodb支持行锁并发高更快，后者表锁；
> 全表扫描：前者遍历聚簇索引慢，后者直接读取顺序文件；
> count：前者扫描行或二级索引慢，后者直接存储总行数；

#### 1.13 索引失效的情况？

>违反最左前缀原则；对索引列使用函数或运算；隐式类型转换；使用！=或<>；
>使用is null或is not nul；使用like以通配符开头；数据分布不均导致优化器放弃索引；使用not in或 not exists。

#### 1.14 MySQL三种日志的作用？

> 二进制日志：主从复制基础、时间点恢复、记录数据变更；
> 重做日志：崩溃恢复、性能优化、WAL技术实现；
> 回滚日志：事务回滚、MVCC实现、保证原子性




## 2. 科大讯飞后端一面

#### 2.1 讲一下集合的框架

> Collection：
>
> * **List**：
>   * ArrayList（动态数组、线程不安全、数组特性、扩容机制1.5倍）、
>   * LinkedList（双向链表、线程不安全、链表特性、无扩容）、
>   * Vector（动态数组、线程安全、扩容机制2倍）；
> * **Set**：
>   * HashSet（底层HashMap、元素顺序无序、允许null、增删查O(1)）;
>   * LinkedHashSet（底层LinkedHashMap、元素按照插入顺序、允许null值、增删改O(1)）
>   * TreeSet（底层TreeMap、元素自然排序、不允许null(除非比较器允许)、增删改O(n)）
> * **Queue**：【ArrayDeque、LinkedList】；
>   Map：SortedMap；
>   * HashMap（数组+链表/红黑树、键无序且允许null、线程不安全、扩容机制2倍）、
>   * LinkedHashMap（同HashMap+双向链表、键插入顺序/访问顺序且允许null、线程不安全、扩容2倍）、
>   * TreeMap（红黑树、键排序且不允许null、线程不安全、无扩容）
>   * HashTable（数组+链表、键无序且不允许null、线程安全、扩容2n+1）

#### 2.2 ConcurrentHashMap和HashMap的区别是什么？

> HashMap：线程不安全、无同步机制、可能抛出并发修改异常、允许null键值；
> ConcurrentHashMap：线程安全、分段锁（jdk8改成了Node数组+cas+syn）、不会抛出并发修改异常、不允许null键值；

#### 2.3 stringbuffer和Stringbuilder有什么区别？

> buffer：线程安全（用syn修饰所有公共方法）、有同步开销、较慢、初始为16自动扩容；
> builder：线程不安全、无同步开销、速度快、初始为16自动扩容；

#### 2.4 线程池创建方式和参数？

> 通过**ExecutorService**工厂类创建（不推荐，隐藏了关键参数配置）
> 通过**ThreadPoolExecutor**：
>
> | 参数名          | 类型                      | 说明                                           |
> | --------------- | ------------------------- | ---------------------------------------------- |
> | corePoolSize    | int                       | 核心线程数，即使空闲也不会被回收的线程数量     |
> | maximumPoolSize | int                       | 最大线程数，线程池允许创建的最大线程数量       |
> | keepAliveTime   | long                      | 非核心线程的空闲存活时间（单位由TimeUnit指定） |
> | unit            | TimeUnit                  | 存活时间的单位（如TimeUnit.SECONDS）           |
> | workQueue       | BlockingQueue\<Runnable\> | 任务队列，用于保存等待执行的任务               |
> | threadFactory   | ThreadFactory             | 线程工厂，用于创建新线程                       |
> | handler         | RejectedExecutionHandler  | 拒绝策略，当任务无法被执行时的处理方式         |
>
> **工作队列类型:**
> LinkedBlockingQueue：无界队列（除非指定容量），可能导致OOM
> ArrayBlockingQueue：有界队列，需指定容量
> SynchronousQueue：不存储元素的队列，每个插入操作必须等待另一个线程的移除操作
> PriorityBlockingQueue：具有优先级的无界队列
> **拒绝策略:**
> AbortPolicy（默认）：直接抛出RejectedExecutionException异常
> CallerRunsPolicy：用调用者所在线程来运行任务
> DiscardPolicy：直接丢弃任务，不抛出异常
> DiscardOldestPolicy：丢弃队列中最老的任务，然后尝试重新提交当前任务

#### 2.5 synchronized和ReentrantLock的区别

> | 特性         | synchronized                                 | ReentrantLock                                                |
> | ------------ | -------------------------------------------- | ------------------------------------------------------------ |
> | **实现级别** | JVM 原生关键字                               | JDK 实现的类 (java.util.concurrent.locks)                    |
> | **锁的获取** | 自动获取和释放（进入同步块获取，退出时释放） | 必须显式调用 lock() 和 unlock()                              |
> | **锁的释放** | 由 JVM 自动管理（即使抛出异常也能保证释放）  | 必须在 finally 块中手动释放                                  |
> | **实现机制** | 基于 monitor 机制（对象头中的 Mark Word）    | 基于 AQS (AbstractQueuedSynchronizer) 实现                   |
> | **锁的类型** | 非公平锁（无法指定）                         | 可选择公平锁或非公平锁（构造参数指定）                       |
> | **获取方式** | 阻塞式获取，无法中断                         | 阻塞获取、尝试获取，立即返回成功/失败、超时等待获取、可中断获取 |
>
> 公平锁与非公平锁：获取锁的顺序是否遵循请求的先后顺序；

#### 2.6 双亲委派机制和优点？

>  **双亲委派机制**：当一个类加载器收到类加载请求时，首先不会自己尝试加载，而是将请求**委派给父类加载器**，这个委派操作会一直向上，直到启动类加载器（Bootstrap ClassLoader）。如果父加载器无法完成加载（在自己的搜索范围内找不到），子加载器才会尝试自己加载。
>
>  每次加载，会依次从启动类加载器、扩展类加载器和应用程序类加载器找；
>
>  **优点**：避免重复加载、核心类库由启动类加载器加载，不可被篡改（安全）、结构清晰。

#### 2.7 常见的类加载机制？

> 双亲委派模型
>
> 线程上下文类加载器（允许子加载器委托父加载器加载类）
>
> OSGi 模块化加载机制（每个模块（Bundle）使用独立的类加载器，实现模块化热部署）
>
> 自定义类加载器

#### 2.8 mysql有哪几种存储引擎？

> | 引擎                      | 事务支持 | 锁粒度 | 外键 | 适用场景          | 典型用途       |
> | ------------------------- | -------- | ------ | ---- | ----------------- | -------------- |
> | **InnoDB**（默认引擎）    | ✅        | 行级锁 | ✅    | 高并发 OLTP       | 订单、用户系统 |
> | **MyISAM**（传统引擎）    | ❌        | 表级锁 | ❌    | 读多写少          | 日志、全文搜索 |
> | **Memory**（内存引擎）    | ❌        | 表级锁 | ❌    | 临时数据/缓存     | 会话存储       |
> | **Archive**（归档引擎）   | ❌        | 行级锁 | ❌    | 历史数据归档      | 审计日志       |
> | **CSV**（文本引擎）       | ❌        | 表级锁 | ❌    | 数据交换          | 导出导入中间表 |
> | **NDB**（集群引擎）       | ✅        | 行级锁 | ❌    | 分布式集群        | 高可用实时系统 |
> | **Federated**（联邦引擎） | ❌        | 表级锁 | ❌    | 跨服务器查询      | 数据聚合       |
> | **Blackhole**（黑洞引擎） | ❌        | -      | ❌    | 数据丢弃/复制中继 | 主从复制       |

#### 2.9 介绍一下aop？

> 面向切面编程，通过**动态代理**或**字节码增强**技术，在不修改原有业务代码的情况下，增强方法的功能。
>
> **核心思想**
>
> - **关注点分离**：将与业务无关的代码（如日志、事务）抽离成独立的模块。
> - **动态织入**：在运行时或编译期将增强代码插入目标方法。
>
> **优点**：
>
>  **解耦横切逻辑**：业务代码更纯净。
>  **复用性高**：一个切面可应用于多个方法。
>  **灵活扩展**：动态增强功能，无需修改源码。
>
> | 场景         | 实现方式                          |
> | ------------ | --------------------------------- |
> | **日志记录** | `@Around` 记录方法入参和返回值    |
> | **事务管理** | `@Transactional`（Spring 已封装） |
> | **权限校验** | `@Before` 拦截未授权请求          |
> | **性能监控** | `@Around` 统计方法执行时间        |
> | **缓存管理** | `@Around` 查询缓存或更新缓存      |

#### 2.10 spring如何解决循环依赖问题？

> Spring 通过 **三级缓存（3-level cache）** 和 **提前暴露对象** 的机制解决循环依赖问题。
>
> | 缓存级别                                | 存储内容                      | 作用                                                  |
> | --------------------------------------- | ----------------------------- | ----------------------------------------------------- |
> | **一级缓存**（`singletonObjects`）      | 完全初始化后的 Bean           | 存放最终可用的 Bean，避免重复创建。                   |
> | **二级缓存**（`earlySingletonObjects`） | 早期暴露的 Bean（未填充属性） | 解决循环依赖时，临时存放半成品 Bean。                 |
> | **三级缓存**（`singletonFactories`）    | Bean 工厂（`ObjectFactory`）  | 生成早期 Bean 的代理对象（用于处理 AOP 代理等场景）。 |



## 3 杂七杂八

#### 3.1 **JVM 的 GC（垃圾回收）机制**

> javaguid

#### 3.2 java锁？

> **隐式锁：synchronized**：基于 对象监视器（Monitor） 实现，无需手动释放锁；缺点：不可中断、非公平锁、不支持超时。
>
> **显式锁：Lock 接口**：如**`ReentrantLock`**
>
> 
>
> 概念：
>
> > **乐观锁 vs 悲观锁**
> >
> > - **悲观锁**：假定并发冲突高（如 `synchronized`、`ReentrantLock`）。
> > - **乐观锁**：假定冲突少，通过 CAS 实现（如 `AtomicInteger`）。
>
> 
>
> **基础锁**：`synchronized` 简单高效，适合大多数场景。
>
> **高级锁**：`ReentrantLock` 提供更灵活的控制。
>
> **读写锁**：`ReadWriteLock` 优化读多写少场景。
>
> **无锁编程**：`CAS` 是高性能并发的终极方案。

#### 3.3 mysql怎么排查慢查询？

> **慢查询**是指执行时间超过预设阈值的 SQL 语句。
>
> **开启慢查询日志**、**实时监控慢查询**、**分析慢查询日志**

#### 3.4 缓存穿透、缓存击穿、缓存雪崩详解

> * **缓存穿透**：查询一个**根本不存在的数据**，导致请求直接穿透缓存层到达数据库，造成数据库压力过大。
>
>   * 解决方案：
>     * 缓存空对象（设置较短过期时间）
>     * 布隆过滤器
>
> * **缓存击穿**：**某个热点key突然失效**，导致大量请求直接打到数据库，造成数据库瞬时压力过大。
>
>   * 与穿透的区别
>     - 穿透：查询的数据**根本不存在**
>     - 击穿：查询的数据**存在但缓存失效**
>
>   * 解决方法：
>     * 互斥锁：当缓存失效时，**只允许一个线程去查询数据库**
>     * 逻辑过期：**不设置物理过期时间**，而是**在数据中存储一个逻辑过期时间**，当发现数据过期时，**异步更新缓存**，并继续返回旧数据，避免阻塞请求
>     * 永不过期：**缓存不设置过期时间**，而是**通过后台任务定期更新缓存**，确保热点数据始终可用。
>
> * **缓存雪崩**：**大量缓存key同时失效**，导致所有请求直接访问数据库，造成数据库崩溃。
>
>   * 解决方法：随机过期时间、多级缓存、熔断降级



## 4 用友java暑期实习一面

#### 4.1 http和https区别？

> | 特性       | HTTP (超文本传输协议) | HTTPS (安全超文本传输协议) |
> | ---------- | --------------------- | -------------------------- |
> | **安全性** | 不加密，明文传输      | 加密传输，安全性高         |
> | **端口**   | 默认端口 80           | 默认端口 443               |
> | **协议层** | 应用层协议            | HTTP + SSL/TLS 加密层      |
>
> HTTPS增加约10%的CPU计算负载
>
> HTTP和HTTPS核心区别在于安全性。HTTP是明文传输，而HTTPS通过SSL/TLS实现加密。具体来说：
>
> 1. HTTPS需要CA（机构）签发的数字证书验证身份；
> 2. 建立连接时通过非对称加密交换密钥，之后用对称加密传输数据；
> 3. 默认端口443，且现代浏览器会对非HTTPS页面标记不安全。

#### 4.2 redis为什么快

> * 内存存储：io、寻址快；
>
> * 高效数据结构设计：
>
>   * 动态字符串(SDS)：预分配空间
>   * 哈希表(dict)：渐进式rehash、自动扩容；
>   * 跳跃表：有序集合实现；
>
> * 单线程架构：
>
>   * 避免多线程的锁开销和上下文切换；
>   * 单命令天然具备原子性；
>   * 无CPU缓存失效；
>   * 配合I/O多路复用
>
> * I/O多路复用技术：使用**epoll/kqueue**系统调用实现高并发
>
>   | 模型         | 连接数限制 | CPU利用率 | 实现复杂度 |
>   | ------------ | ---------- | --------- | ---------- |
>   | 阻塞I/O      | 约1000线程 | 低        | 简单       |
>   | select/poll  | 约1024连接 | 中        | 中等       |
>   | epoll/kqueue | 10万+连接  | 高        | 复杂       |
>
> * 精心优化的网络协议：二进制安全（支持任何字符集）、极简解析。
>
> * 持久化优化策略：提供两种持久化方式且不影响性能
>
>   | **方式** | **原理**                   | **性能影响**          |
>   | -------- | -------------------------- | --------------------- |
>   | RDB快照  | 定时fork子进程全量备份     | 主进程几乎不受影响    |
>   | AOF日志  | 追加写入（可配置每秒同步） | fsync策略决定开销大小 |

####  4.3 springbootapplication注解的组成

> `@SpringBootApplication`是Spring Boot最核心的注解，它是一个**复合注解**，由三个关键注解组合而成，提供了Spring Boot应用的默认配置和自动装配能力。
>
> **源码：**
>
> ```java
> @Target(ElementType.TYPE)
> @Retention(RetentionPolicy.RUNTIME)
> @Documented
> @Inherited
> @SpringBootConfiguration
> @EnableAutoConfiguration
> @ComponentScan(excludeFilters = {
>  @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
>  @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) 
> })
> public @interface SpringBootApplication {
>  // 省略其他属性...
> }
> ```
>
> * (1) `@SpringBootConfiguration`
>   - **作用**：标识当前类为配置类
>   - **本质**：是`@Configuration`的特化版本
> * (2) `@EnableAutoConfiguration`
>   - **作用**：启用Spring Boot的自动配置机制
>   - **实现原理：**
>     - 通过`@Import(AutoConfigurationImportSelector.class)`加载自动配置
>     - 从`META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`加载配置类
>     - 基于条件注解（如`@ConditionalOnClass`）决定是否生效
> * (3) `@ComponentScan`
>   - **作用**：自动扫描组件
>   - **默认行为：**
>     - 扫描当前包及其子包
>     - 包含`@Component`, `@Service`, `@Repository`, `@Controller`等注解的类

#### 4.4 三次握手

> ![image-20250505104611021](https://github.com/user-attachments/assets/678ea9ea-1563-43b3-96e8-bcf584ba2f68)

>
> | 握手次数 | 解决的问题         | 如果缺少会怎样                 |
> | -------- | ------------------ | ------------------------------ |
> | 第一次   | 客户端发送能力正常 | 服务器无法确认客户端存在       |
> | 第二次   | 服务器收发能力正常 | 客户端无法确认服务器存在       |
> | 第三次   | 客户端接收能力正常 | 服务器无法确认客户端能接收数据 |
>
> - 前两个SYN包**不能**携带应用数据（RFC 793规定）
> - 第三次ACK**可以**携带数据（TCP Fast Open特性除外）

#### 4.5 mysql的锁的种类

> **按锁粒度分类**：
>
> * 全局锁（数据库实例）；
> * 表级锁；
> * 行级锁：记录锁（索引记录）、间隙锁（索引记录之间的间隙，防止幻读）、 临键锁（记录锁 + 间隙锁）、插入意向锁（插入操作前设置，多个事务不冲突时可同时持有）；
>
> **按锁模式分类**：共享锁（多个事务可同时持有）、 排他锁、意向锁（意向共享锁、意向排他锁，快速判断表内是否有行锁）、
>
> **特殊锁类型**：自增锁（自增列插入时）、谓词锁（空间索引）

#### 4.6 mysql索引、主键、唯一索引、联合索引区别

> | 索引类型 | 关键特性                   | 是否允许NULL | 数量限制  | 是否聚簇      | 典型应用场景                   |
> | -------- | -------------------------- | ------------ | --------- | ------------- | ------------------------------ |
> | 主键索引 | 唯一标识记录，NOT NULL约束 | ❌不允许      | 每表仅1个 | ✅(InnoDB)     | 表的主标识字段                 |
> | 唯一索引 | 保证列值唯一性             | ✅允许        | 每表多个  | ❌             | 业务唯一约束(如用户名、手机号) |
> | 普通索引 | 加速查询，无约束           | ✅允许        | 无限制    | ❌             | 高频查询字段                   |
> | 联合索引 | 多列组合的索引结构         | 依列属性而定 | 无限制    | ❌(除非是主键) | 多条件组合查询                 |

#### 4.7 innodb的事务隔离级别

> | 隔离级别             | 脏读 | 不可重复读 | 幻读 | 并发性能 | 实现机制                 |
> | -------------------- | ---- | ---------- | ---- | -------- | ------------------------ |
> | READ UNCOMMITTED     | ❌    | ❌          | ❌    | 最高     | 无锁读取                 |
> | READ COMMITTED (RC)  | ✅    | ❌          | ❌    | 高       | 快照读 + 记录锁          |
> | REPEATABLE READ (RR) | ✅    | ✅          | ⚠️    | 中       | 快照读 + 记录锁 + 间隙锁 |
> | SERIALIZABLE         | ✅    | ✅          | ✅    | 最低     | 全表锁/自动加共享锁      |
>
> ✅ = 防止;  ❌ = 不防止;  ⚠️ = InnoDB特殊处理可防止



## 5 PDD 暑期实习 二面面经

#### 5.1 布隆过滤器误判原理?如何减少误判率?

> 使用**多个哈希函数**对元素进行映射。判断存在，可能误判；判断不存在，一定不存在。
>
> 降低误判率的五大核心策略：增大位数组容量(m)、 优化哈希函数数量（）、选择高质量的哈希函数、动态扩容方案（分层-第一层超过阈值用两层，Scalable Bloom Filter）、数据预热优化

#### 5.2 CAS的思想?

>  CAS（Compare-And-Swap）是一种**无锁并发原子操作**，
>
>  核心思想：当需要修改某个共享变量的值时，先比较该变量当前值是否与预期值（读取时的旧值）一致，若一致则原子性地更新为新值，否则放弃操作（通常配合重试机制）。

#### 5.3 java的volatile?能保证线程安全吗?

> * 轻量级同步机制，提供两大保证：
>
> 1. 可见性保证：对volatile变量的写操作会立即刷新到主内存，读操作会直接从主内存读取最新值；
> 2. 禁止指令重排序：编译器/runtime/CPU不会对volatile变量的操作与其他内存操作进行重排序；
>
> * 不能完全保证线程安全。
>   * 可以保证--（单一写多读场景）；
>   * 不能保证--（复合操作：任何需要"读取-修改-写入"的操作
>
> ​					  多线程写操作：多个线程同时修改volatile变量
>
> ​					  依赖当前值的操作：检查后执行(check-then-act)模式（如不变式约束））
>
> * **volatile** vs **synchronized**
>
>   | 特性     | volatile                | synchronized            |
>   | -------- | ----------------------- | ----------------------- |
>   | 原子性   | 仅保证单次读/写的原子性 | 保证代码块/方法的原子性 |
>   | 可见性   | 保证                    | 保证                    |
>   | 互斥性   | 不提供                  | 提供                    |
>   | 性能     | 更高                    | 较低（涉及锁获取/释放） |
>   | 适用场景 | 状态标志、一次性发布    | 复合操作、临界区保护    |
>
> * **正确使用volatile的建议**
>
>   1. 确保变量状态完全由其当前值决定
>   2. 变量不需要参与不变式约束（即不依赖其他变量的值）
>   3. 访问变量时不需要加锁
>   4. 变量不会被多个线程同时修改

#### 5.4 线程池的线程饥饿问题，解决方案?

> * 在线程池中，某些任务由于资源分配策略或调度问题而**长期得不到执行机会**的现象。这些任务虽然被提交到了线程池，但由于各种原因无法获取到线程资源来执行，导致任务积压或响应延迟。
> * 常见场景：固定大小线程池+长任务阻塞、不合理的任务优先级、资源死锁；
> * 解决方案：
>
>   * 合理配置线程池；
>   * 使用不同的线程池隔离任务（长、短任务）；
> * 设置任务超时时间；
>   * 使用工作窃取线程池；
> * 监控和预警；



## 6 航旅纵横java暑期实习

#### 6.1 redis的持久化机制？

> 主要通过两种方式实现：**RDB（Redis Database）** 和 **AOF（Append Only File）**实现；**RDB**：在指定时间间隔内将内存数据生成一个二进制快照文件（`dump.rdb`），保存的是键值对的全量数据。
>
> * 优点：恢复速度快、备份简单
>
> * 缺点：有数据丢失风险【两快照间数据可能因宕机丢失】、性能开销；
>
> **AOF**：记录所有写操作命令，以文本协议格式追加到文件末尾（`appendonly.aof`）。
>
> * 同步策略（通过 appendfsync 配置）：
>   * always：每次写操作后立即同步到磁盘（最安全，性能最低）。
>   * everysec：每秒批量同步一次（推荐，平衡安全与性能）。
>   * no：由操作系统决定何时同步（不可控，风险高）。
> * 优点：数据安全性更高【最多丢失 1 秒数据（everysec 模式）】、可读性强【AOF 文件为文本格式，可人工阅读和修复】；
> * 缺点：文件体积较大【比 RDB 大】、恢复速度较慢【需逐条执行】；
>
> **混合持久化：**以 RDB 格式存储全量数据，后续的写操作追加到 AOF 文件中。前半部分为 RDB 快照，后半部分为 AOF 日志。
>
> * 优点：
>   * 快速恢复：RDB 部分快速加载，AOF 部分补全最新数据。
>   * 数据安全：避免 RDB 的数据丢失问题，同时减少 AOF 重写开销。

#### 6.2 主从复制原理？

> Redis 的主从复制（Replication）：数据同步机制，通过将主节点（Master）的数据复制到一个或多个从节点（Slave）实现数据冗余、读写分离和故障恢复。
>
> 本质是 数据同步，分为 **全量同步** 和 **增量同步** 两个阶段，基于：
>
> * **异步复制**：主节点在写入数据后，异步将数据同步给从节点（默认模式，高性能但可能丢失少量数据）。
> * **基于偏移量的增量同步**：通过复制偏移量（`offset`）和复制积压缓冲区（`repl_backlog`）实现断点续传。
> * **心跳检测**：主从节点通过 `PING`/`PONG` 保持连接，检测网络健康状态。
> * 主从复制 vs. 集群
>
> | **特性**     | **主从复制**     | **Redis Cluster**    |
> | ------------ | ---------------- | -------------------- |
> | **数据分布** | 所有节点数据相同 | 数据分片（Sharding） |
> | **扩展性**   | 适合读扩展       | 支持读写扩展         |
> | **故障转移** | 需配合 Sentinel  | 内置自动故障转移     |

#### 6.3 缓存穿透、缓存击穿和缓存雪崩?

> 看上文。

#### 6.2 线程池的参数有哪些?

> 参考上文；

#### 6.3 redis分布式锁的原理？
> 利用 Redis 的原子性操作实现对共享资源的互斥访问，确保在分布式系统中同一时间只有一个客户端能持有锁。
> 

#### 6.4 MySQL怎么实现分布式锁，要设置哪些字段？


#### 6.5 哨兵集群里面的脑裂问题；怎么解决？


#### 6.6 MySQL B+树和B树的区别？


#### 6.7 高可用场景题？
> 给商户发优惠券系统的管理端。有 10 万那个商户会使用这个渠道，每个商户会拿着 10 万个手机号放到 Excel 表格里上传到管理端，你觉得这个流程该怎么做？以及我们要保证它的这个流程的高可用？


#### 6.8 有一个接口突然变的很慢，怎么快速解决；后续怎么排查原因?



## 7 京东零售-平台产品和研发中心后端一面

#### 7.1 说一下哈希表（HashMap）的实现原理？

> **数据结构：**数组+链表/红黑树结构【Java的HashMap底层是一个Node数组，每个数组元素是一个链表或红黑树(JDK8+)】
>
> 当多个key映射到同一数组索引时，形成链表；
>
> JDK8后，当链表长度超过8时转换为红黑树 (且![image](https://cdn.nlark.com/yuque/__latex/ab7db5447f82f79b14b90f97e2a7ec75.svg) 时)，当红黑树节点数<6时，转回链表。

#### 7.2  为什么链表长度为8时，要转换成红黑树？

> 经过测试和统计，当链表长度达到8时，红黑树的综合性能开始优于链表。



#### 7.3 什么情况会破坏双亲委派机制？

> + SPI（Service Provider Interface）服务发现机制：JDBC、JNDI等；
> + 热部署/热替换需求：OSGi框架、Tomcat等Web容器的JSP热部署、JRebel等热部署工具；
> + 用户自定义类加载器覆盖：实现自己的类加载逻辑、隔离不同模块的类加载；
> + Tomcat等Web容器的类加载设计；
> + OSGi的类加载机制；
> + 动态代理技术；

> + 核心接口由启动类加载器加载（如`java.sql.Driver`）
> + 实现类由应用类加载器加载
> + 需要父类加载器请求子类加载器完成类加载

> + 需要动态加载和卸载类
> + 不同版本的类可能需要并行存在
> + 传统的双亲委派无法满足这种灵活性

#### 7.4 说一下SPI和热加载？

> + SPI（Service Provider Interface）：Java提供的一种服务发现机制，允许第三方为接口提供实现，核心思想是**接口与实现分离**。
> + SPI工作原理：
>
> 
>
>     1. 定义接口【在核心库中定义服务接口】
>     2. 提供实现【在META-INF/services目录下创建以接口全限定名命名的文件】
>     3. 加载实现【通过`ServiceLoader`动态加载实现类】
>
> + 热加载是指在不重启应用的情况下，动态更新类或资源文件的能力。
> + 热加载实现原理：
>   1. 自定义类加载器【为每个需要热加载的模块创建独立的类加载器】
>   2. 类卸载机制【当类加载器被回收时，其加载的类才能被卸载】
>   3. 文件监控【监控class文件变化触发重新加载】

#### 7.5 说一下Java内存模型

> + Java内存模型（Java Memory Model, JMM）包括**主内存**与**工作内存**。
> + JMM定义了8种原子操作来控制主内存与工作内存之间的交互：lock（锁定）、unlock（解锁）、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）
> + 三大特性：
>   - 原子性(Atomicity)
>     * 保证基本数据类型的访问读写是原子性的（除long/double）
>     * 通过`synchronized`和`Lock`保证代码块的原子性
>   - 可见性(Visibility)
>     * 一个线程修改了共享变量，其他线程能立即看到修改
>     * 实现方式：
>       + `volatile`关键字
>       + `synchronized`（解锁前必须同步到主内存）
>       + `final`（正确初始化后不可变）
>   - 有序性(Ordering)
>     * 禁止指令重排序优化
>     * 通过以下方式保证：
>       + `volatile`的禁止重排序语义
>       + `synchronized`的"一个变量同一时刻只允许一条线程对其lock"规则
>       + happens-before原则
> + happens-before原则（JMM定义的一系列保证内存可见性的规则）：
>   1. **程序顺序规则**：同一线程中的操作，前面的happens-before后面的
>   2. **监视器锁规则**：解锁操作happens-before后续的加锁操作
>   3. **volatile规则**：volatile变量的写操作happens-before后续的读操作
>   4. **线程启动规则**：Thread.start() happens-before线程中的任何操作
>   5. **线程终止规则**：线程中的所有操作happens-before其他线程检测到该线程已终止
>   6. **中断规则**：对线程interrupt()的调用happens-before被中断线程检测到中断
>   7. **终结器规则**：对象的构造函数happens-before它的finalize()方法
>   8. **传递性**：如果A happens-before B，且B happens-before C，那么A happens-before C
> + volatile关键字：保证变量的**可见性**、禁止指令**重排序**。



#### 7.6 为什么内存模型要这么划分，以及会出现哪些问题

> 为了解决多线程编程中的核心挑战；
>
> **原因：** 
>
> + 硬件层面：
>   - CPU缓存架构**：**cpu多级缓存导致内存访问速度不一致；
>   - 缓存一致性协议**：**不同硬件对缓存一致性协议实现不同；
>   - 指令重排序**：**CPU和编译器会优化指令执行顺序；
> + 性能优化：工作内存减少线程访问主内存的次数，提高性能；
> + 并发编程的复杂性：直接操作主内存会导致复杂的同步问题
>
> **可能会出现的问题：**
>
> + 可见性问题：【一个线程修改了共享变量，另一个线程看不到修改】修改只发生在工作内存，没有及时刷新到主内存。
> + 原子性问题：【操作被中途打断，导致结果不符合预期】除long/double外的基本类型读写是原子的，但复杂操作不是。
> + 有序性问题：【执行顺序与编写顺序不一致】指令重排序优化

#### 7.7 事务ACID特性都是怎么实现的？

#### 7.8 慢查询了解多少？

#### 7.9 分库分表了解多少，会存在什么问题？

#### 7.10 Redis会丢数据吗？ 除了持久化的丢数据，还有什么情况会丢数据

#### 7.11 Redis的缓存雪崩、缓存击穿和缓存穿透

> 看前面

#### 7.12 生产者消费者模型的应用场景

#### 7.13 简单说一下IoC和AOP，没有IoC会怎么样？

> AOP



